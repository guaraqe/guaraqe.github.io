<!DOCTYPE html>
<html lang="en">
<head profile="http://www.w3.org/2005/10/profile">
    <meta charset="UTF-8">
    <meta name="description" content="Exploring deduction, induction, and abduction in software development
through Peirce’s theory
">
    <meta name="author" content="Juan Raphael Diaz Simões">
    <meta name="keywords" content="Haskell, functional programming, software engineering, bioinformatics, performance optimization, Juan Simões">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="robots" content="index, follow">
    <title>Code is engineering, types are science
</title>
    
    <!-- Open Graph / Social Media -->
    <meta property="og:type" content="article">
    <meta property="og:title" content="Code is engineering, types are science
">
    <meta property="og:description" content="Exploring deduction, induction, and abduction in software development
through Peirce’s theory
">
    <meta property="og:url" content="https://guaraqe.github.io/posts/2020-03-05-peirce.html">
    <meta property="og:site_name" content="Juan Raphael Diaz Simões">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary">
    <meta name="twitter:title" content="Code is engineering, types are science
">
    <meta name="twitter:description" content="Exploring deduction, induction, and abduction in software development
through Peirce’s theory
">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="https://guaraqe.github.io/posts/2020-03-05-peirce.html">
    
    <!-- JSON-LD Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "BlogPosting",
      "name": "Code is engineering, types are science
",
      "description": "Exploring deduction, induction, and abduction in software development
through Peirce’s theory
",
      "url": "https://guaraqe.github.io/posts/2020-03-05-peirce.html",
      "author": {
        "@type": "Person",
        "name": "Juan Raphael Diaz Simões",
        "url": "https://guaraqe.github.io"
      },
      "publisher": {
        "@type": "Person",
        "name": "Juan Raphael Diaz Simões"
      },
      "inLanguage": "en-US"
    }
    </script>
    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/css/syntax.css">
    <link href="https://cdn.jsdelivr.net/npm/daisyui@3.1.0/dist/full.css" rel="stylesheet" type="text/css" />
    <script src="https://cdn.tailwindcss.com"></script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.css" integrity="sha384-GvrOXuhMATgEsSwCs4smul74iXGOixntILdUW9XmUC6+HX0sLNAK3q71HotJqlAn" crossorigin="anonymous">

    <!-- The loading of KaTeX is deferred to speed up page rendering -->
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.8/dist/katex.min.js" integrity="sha384-cpW21h6RZv/phavutF+AuVYrr+dA8xD9zs6FwLpaCct6O9ctzYFfFr4dgmgccOTx" crossorigin="anonymous"></script>

    <!-- To automatically render math in text elements, include the auto-render extension: -->
    <script>document.addEventListener("DOMContentLoaded", function () {
   var mathElements = document.getElementsByClassName("math");
   var macros = [];
   for (var i = 0; i < mathElements.length; i++) {
    var texText = mathElements[i].firstChild;
    if (mathElements[i].tagName == "SPAN") {
     katex.render(texText.data, mathElements[i], {
      displayMode: mathElements[i].classList.contains('display'),
      throwOnError: false,
      macros: macros,
      fleqn: false
     });
  }}});
    </script>

</head>
<body>
    <header>
        <div class="navbar bg-base-100 px-4 py-3">
          <div class="navbar-start">
            <a href="/" class="flex items-center group">
              <img src="/images/juan.png" alt="Juan Simões" class="w-8 h-8 rounded-full object-cover mr-3 group-hover:scale-105 transition-transform">
              <span class="text-lg font-medium text-gray-800 group-hover:text-blue-600 transition-colors hidden sm:inline">Juan Raphael Diaz Simões</span>
              <span class="text-lg font-medium text-gray-800 group-hover:text-blue-600 transition-colors sm:hidden">Juan Simões</span>
            </a>
          </div>
          <div class="navbar-end">
            <div class="hidden sm:block">
              <ul class="menu menu-horizontal text-sm space-x-1">
                <li><a href="/posts" class="hover:bg-gray-100 rounded-md px-2 py-1 transition-colors">Writing</a></li>
                <li><a href="/courses" class="hover:bg-gray-100 rounded-md px-2 py-1 transition-colors">Education</a></li>
                <li><a href="/cv.html" class="hover:bg-gray-100 rounded-md px-2 py-1 transition-colors">CV</a></li>
                <li><a href="/projects.html" class="hover:bg-gray-100 rounded-md px-2 py-1 transition-colors">Projects</a></li>
              </ul>
            </div>
            <div class="block sm:hidden">
              <div class="grid grid-cols-2 gap-1 text-xs">
                <a href="/posts" class="hover:bg-gray-100 rounded-md px-2 py-1 transition-colors text-center">Writing</a>
                <a href="/cv.html" class="hover:bg-gray-100 rounded-md px-2 py-1 transition-colors text-center">CV</a>
                <a href="/courses" class="hover:bg-gray-100 rounded-md px-2 py-1 transition-colors text-center">Education</a>
                <a href="/projects.html" class="hover:bg-gray-100 rounded-md px-2 py-1 transition-colors text-center">Projects</a>
              </div>
            </div>
          </div>
        </div>
    </header>
    <div class="md:flex justify-center bg-base-100">
    <article class="prose max-w-prose">
        <header>
            <h1 class="text-3xl mb-5">
                Code is engineering, types are science

            </h1>
            <time class="mb-5 block text-gray-600" datetime="2020-03-05">March  5, 2020</time>
        </header>

        <main>
            <p class="mb-3">I wrote a post for <a class="link link-hover text-zinc-600" href="https://www.tweag.io">Tweag</a> on deduction, induction and abduction, from a perspective of software development. You can find the original <a class="link link-hover text-zinc-600" href="https://www.tweag.io/blog/2020-03-05-peirce/">here</a>.</p>
<h1 class="text-2xl mt-5 mb-5" data-number="1" id="introduction"><span class="header-section-number">1</span> Introduction</h1>
<p class="mb-3">Programming is a diverse activity that requires reasoning in many different ways. Sometimes one has to think like an engineer—find the best solution for a problem under multiple constraints. Other times, one has to think like a scientist—observe the data points you have in order to establish general rules that help you attain your goals. These patterns of thinking have very different natures.</p>
<p class="mb-3">In this blog post, I will explain these patterns through the theory of reasoning of <a class="link link-hover text-zinc-600" href="https://en.wikipedia.org/wiki/Charles_Sanders_Peirce">Charles Sanders Peirce</a>. Peirce divides reasoning into three complementary processes<a class="link link-hover text-zinc-600" href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>: <em>deduction</em>, <em>abduction</em> and <em>induction</em>. In the following sections we will go through these logical processes and see how they relate to software.</p>
<center>
<img title="Charles Sanders Peirce" src="https://upload.wikimedia.org/wikipedia/commons/5/58/Charles_Sanders_Peirce.jpg" style="width:300px;margin-bottom:20px;"></img>
</center>
<p class="mb-3">But before starting, I want to make explicit the underlying subject of this post: <a class="link link-hover text-zinc-600" href="https://en.wikipedia.org/wiki/Plausible_reasoning">plausible reasoning</a>. Plausible reasoning does not imply certainty or truth—it better reflects the concept of an educated guess. At minimum, these guesses must not be contradicted by the information we have at hand. At best, with more information, we can choose the guess with the most chance of being true. With that out of the way, let’s dive into our definitions.</p>
<h1 class="text-2xl mt-5 mb-5" data-number="2" id="deduction"><span class="header-section-number">2</span> Deduction</h1>
<p class="mb-3">Deduction is the process of reasoning that we acknowledge the most. It is what we learn in mathematics, and also what we think about when talking about logic. The basic schema is the following: if we know a fact <code>A</code>, and we know that <code>A</code> implies <code>B</code>, then we know the fact <code>B</code> (<em>modus ponens</em>). We will represent this process with the following <a class="link link-hover text-zinc-600" href="https://ncatlab.org/davidcorfield/show/deduction%2C+induction%2C+abduction">diagram</a>:</p>
<center>
<img title="Deduction" src="./img/peirce-deduction.svg" style="margin-bottom:20px;"></img>
</center>
<p class="mb-3">In philosophy books, it is very common to identify the sides of this triangle with the following phrases:</p>
<ul class="list-disc list-outside mt-1 mb-3 pl-5">
<li>Socrates is human (left).</li>
<li>Every human is mortal (right).</li>
<li>Therefore Socrates is mortal (bottom).</li>
</ul>
<p class="mb-3">which can be useful when trying to identify the reasoning patterns we will see next.</p>
<p class="mb-3">The practical utility of deduction is that it is able to reduce the scope of a problem: if we want to achieve <code>B</code>, and we know that <code>A</code> implies <code>B</code>, we can change our goal to <code>A</code> if we think that is useful.</p>
<p class="mb-3">One particularity of deduction is that the result of a deduction is the <em>certainty</em> of a fact: if we achieve <code>A</code>, we are certain to achieve <code>B</code>. As we will see, this is not the case for the other reasoning processes.</p>
<p class="mb-3">In Haskell programming, for example, deduction is omnipresent. Every time you apply a function of type <code>a -&gt; b</code> to a value of type <code>a</code> in order to produce a value of type <code>b</code>, you apply deductive reasoning.</p>
<h1 class="text-2xl mt-5 mb-5" data-number="3" id="abduction"><span class="header-section-number">3</span> Abduction</h1>
<p class="mb-3">A client sends you a bug report describing some anomalous behavior in the software you work on. You run it locally, and observe the same behavior. After some changes in the code you do not observe the offending behavior anymore, and declare the bug as solved.</p>
<p class="mb-3">The first thing to notice is that the reasoning above is not logically correct. Indeed, we can simplify it as follows:</p>
<ul class="list-disc list-outside mt-1 mb-3 pl-5">
<li>I don’t see the behavior anymore.</li>
<li>If the bug is solved, I should not see the behavior.</li>
<li>Therefore, I solved the bug.</li>
</ul>
<p class="mb-3">It is possible that the anomalous behavior was the result of two interacting parts, and your manipulation of one of them made the underlying cause of the bug, present in the other component, not visible anymore. However this is plausible reasoning—given the constraints you have (the observation or not of bugs locally), you managed to propose a solution that is coherent, non-contradicting, that has a chance of being correct. And as developers, we know that very often, this works.</p>
<p class="mb-3">The mechanism of abduction is the following: if we know a fact <code>B</code>, and we know that <code>A</code> implies <code>B</code>, then we abduce <code>A</code> as a plausible thing. This can be represented in the following diagram:</p>
<center>
<img title="Abduction" src="./img/peirce-abduction.svg" style="margin-bottom:20px;"></img>
</center>
<p class="mb-3">Abduction is the process that we identify with writing code and engineering, since it is about solving a problem <em>under constraints</em>. This is not the only component of engineering, but it is one of its defining aspects. In the case of the diagram above, for example, the constraint is knowing that <code>A</code> implies <code>B</code>.</p>
<p class="mb-3">We can now connect abduction with writing code in a typed language. What happens when we try to make an <em>action plan</em> based on abductive reasoning? If we take <code>A</code> to correspond to “code works” and <code>B</code> to correspond to “code typechecks”, we can act using abduction as follows:</p>
<ul class="list-disc list-outside mt-1 mb-3 pl-5">
<li>I want to write working code.</li>
<li>My only information is that working code must typecheck.</li>
<li>Therefore, I try to write code that typechecks so that it can work.</li>
</ul>
<p class="mb-3">This reasoning can be successful or unsuccessful depending on the context. It has almost no chance of working in the C language, but has a very good chance of working if you doing something simple in Idris. It can also describe the experience of a beginner in a Haskell codebase, and the expression “just follow the types”. This will not necessarily lead to working code, but will allow the user to run the code and obtain more information about it.</p>
<p class="mb-3">In summary, abduction corresponds to using all the information one has in order to obtain a reasonable, or if the context permits, the best solution to a problem. This is typically the job of the engineer, and something that any programmer can relate to: do the best you can under the constraints you have.</p>
<h1 class="text-2xl mt-5 mb-5" data-number="4" id="induction"><span class="header-section-number">4</span> Induction</h1>
<p class="mb-3">Your company’s server crashed at a given time last night. You read the log files and see that there is an “out of memory” error timestamped to the moment of the server crash. Therefore, you diagnose this error as the culprit for the server crash.</p>
<p class="mb-3">The first thing to notice is that the reasoning above is not logically correct. Indeed, we can simplify it as follows:</p>
<ul class="list-disc list-outside mt-1 mb-3 pl-5">
<li>The out of memory error happened at time T.</li>
<li>The server crashed at time T.</li>
<li>Therefore, the out of memory error caused the server to crash.</li>
</ul>
<p class="mb-3">Indeed, it can be that case that this error was safely caught and the server crashed because of an electricity problem. However this is plausible reasoning — given two facts that have the same origin (the same moment in time), you managed to establish a causality that is coherent, non-contradicting, that has a chance of being correct. And as developers, we know that very often, this works.</p>
<p class="mb-3">The mechanism of induction <a class="link link-hover text-zinc-600" href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> is the following: if we know a fact <code>B</code> and we know a fact <code>A</code>, then we induce <code>A</code> implies <code>B</code> as a plausible thing. This can be represented in the following diagram:</p>
<center>
<img title="Induction" src="./img/peirce-induction.svg" style="margin-bottom:20px;"></img>
</center>
<p class="mb-3">Induction is the process that we identify with writing types and science, especially with natural sciences, because it is about establishing <em>constraints</em> and <em>general rules</em> that limit possible behaviors. This is not the only component of science, but it is one of its defining aspects. In the case of the diagram above, for example, the constraint is the established constraint is that <code>A</code> implies <code>B</code>.</p>
<p class="mb-3">We can now connect induction with writing types for a library. What happens when we try to make an <em>action plan</em> based on inductive reasoning? If we take <code>A</code> to correspond to “code is wrong” and <code>B</code> to correspond to “code does not typecheck”, we can act using induction as follows:</p>
<ul class="list-disc list-outside mt-1 mb-3 pl-5">
<li>I know some code is wrong, and I want to avoid it in production.</li>
<li>Code that doesn’t typecheck doesn’t run.</li>
<li>Therefore, I write types so that this code does not typecheck.</li>
</ul>
<p class="mb-3">This corresponds to the post-hoc type modelling of an existing codebase, that tries to preserve important invariants and prevent future errors. The establishment of a type system is akin to the creation of a general rule that allows some desirable code examples to be valid, and undesirable ones to not exist.</p>
<p class="mb-3">In summary, induction corresponds to establishing an environment of constraints and rules so that others, while working under these conditions, produce the outcomes that are expected. This is typically the job of managers, and present in many other activities, like teaching and parenting. This is also one of the roles of scientific theories, to constrain the space of possibilities when developing an engineering project.</p>
<h1 class="text-2xl mt-5 mb-5" data-number="5" id="conclusion"><span class="header-section-number">5</span> Conclusion</h1>
<p class="mb-3">Here’s the takeaway:</p>
<ul class="list-disc list-outside mt-1 mb-3 pl-5">
<li><p class="mb-3">Even the most well-informed decisions we take are not logical conclusions of facts - they are most often just plausible theories. At minimum, they must not be false, but if possible, we must use the information we have at hand to make the best decision.</p></li>
<li><p class="mb-3">Abduction and induction are simple mechanisms yet omnipresent. Being able to identify whether we are using one of them makes it easier to know how to find the weak points and to better justify our arguments. Abductions and inductions always require arguments.</p></li>
<li><p class="mb-3">Being able to identify where plausible reasoning was used in some decision process can show where possible errors can happen, or where new data can show problems that were not foreseen before.</p></li>
</ul>
<p class="mb-3">In another note, what about writing tests? This is also an inductive activity like writing types, they only differ in breadth and power—while types can be imposed not only to developers, but also to users of a library, tests can impose constraints that are unavailable to a type system.</p>
<p class="mb-3">Globally, the message is that programming involves activities of different natures. Sometimes you are just plumbing functions together and you have to think like a mathematician. Sometimes you are writing functions and have to work under constraints and think like an engineer. And sometimes you have to establish frameworks and give appropriate constraints to yourself and your coworkers, work with the evidence you have and think like a scientist. And no part in this game is more or less important than the others. They are different, yet complementary.</p>
<section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes">
<hr />
<ol class="list-decimal list-outside mt-1 mb-3 pl-5">
<li id="fn1"><p class="mb-3"><em>Benjamin S. Peirce</em>, Philosophical writings of Peirce, 1955<a class="link link-hover text-zinc-600" href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p class="mb-3">Mathematical induction, the technique for proving theorems about integer numbers, for example, is not an example of induction as written here. They share the same name, but they are not related.<a class="link link-hover text-zinc-600" href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
        </main>

        <br>
        <br>
    </article>
</div>

</body>
</html>
